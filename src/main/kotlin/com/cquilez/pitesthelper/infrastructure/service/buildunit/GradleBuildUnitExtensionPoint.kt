package com.cquilez.pitesthelper.infrastructure.service.buildunit

import com.cquilez.pitesthelper.domain.BuildSystem
import com.cquilez.pitesthelper.domain.BuildUnit
import com.cquilez.pitesthelper.domain.CodeType
import com.cquilez.pitesthelper.domain.SourceFolder
import com.cquilez.pitesthelper.infrastructure.adapter.buildunit.AbstractBuildUnitExtensionPoint
import com.cquilez.pitesthelper.infrastructure.service.sourcefolder.SourceFolderService
import com.intellij.openapi.components.service
import com.intellij.openapi.module.Module
import com.intellij.openapi.module.ModuleManager
import com.intellij.openapi.project.Project
import com.intellij.openapi.roots.ContentEntry
import com.intellij.openapi.roots.ModuleRootManager
import kotlinx.collections.immutable.toImmutableSet
import org.jetbrains.jps.model.java.JavaSourceRootType
import java.nio.file.Path
import kotlin.io.path.Path

class GradleBuildUnitExtensionPoint : AbstractBuildUnitExtensionPoint() {

    override fun getBuildSystem(): BuildSystem = BuildSystem.GRADLE

    override fun scanBuildUnits(project: Project): List<BuildUnit> {
        val sourceFolderService = project.service<SourceFolderService>()
        val allModules = ModuleManager.getInstance(project).modules.toList()
        val buildFileInfoList = detectAllBuildFiles(allModules, sourceFolderService)
        return buildHierarchyFromBottomToTop(buildFileInfoList)
    }

    private fun detectAllBuildFiles(
        allModules: List<Module>,
        sourceFolderService: SourceFolderService
    ): List<BuildFileInfo> {
        val buildFileLocations =
            mutableMapOf<Path, Pair<Path, String>>()

        for (module in allModules) {
            val contentRoots = ModuleRootManager.getInstance(module).contentRoots

            for (contentRoot in contentRoots) {
                val buildFile = contentRoot.findChild("build.gradle.kts")
                    ?: contentRoot.findChild("build.gradle")
                    ?: contentRoot.findChild("settings.gradle.kts")
                    ?: contentRoot.findChild("settings.gradle")

                if (buildFile != null && buildFile.exists()) {
                    val buildFilePath = Path(buildFile.path)
                    val buildUnitDir = buildFilePath.parent
                    buildFileLocations[buildUnitDir] = Pair(buildFilePath, buildFile.name)
                }
            }
        }

        val allBuildUnitDirs = buildFileLocations.keys.toImmutableSet()
        return buildFileLocations.map { (buildUnitDir, buildFileInfo) ->
            val (buildFilePath, buildFileName) = buildFileInfo
            val nestedBuildUnitDirs = allBuildUnitDirs.filter { otherDir ->
                otherDir != buildUnitDir && otherDir.startsWith(buildUnitDir)
            }.toSet()

            val sourceFolders = findSourceFoldersInRelatedModules(
                buildUnitDir,
                nestedBuildUnitDirs,
                allModules,
                sourceFolderService
            )
            BuildFileInfo(BuildSystem.GRADLE, buildFilePath, buildFileName, sourceFolders)
        }
    }

    private fun findSourceFoldersInRelatedModules(
        buildUnitDir: Path,
        nestedBuildUnitDirs: Set<Path>,
        allModules: List<Module>,
        sourceFolderService: SourceFolderService
    ): List<SourceFolder> {
        val sourceFolders = mutableListOf<SourceFolder>()

        for (module in allModules) {
            val moduleRootManager = ModuleRootManager.getInstance(module)

            for (contentEntry in moduleRootManager.contentEntries) {
                val contentRootPath = contentEntry.file?.path?.let { Path(it) } ?: continue

                getSourceFolderFromContentRoot(
                    contentRootPath,
                    buildUnitDir,
                    nestedBuildUnitDirs,
                    contentEntry,
                    sourceFolderService,
                    sourceFolders
                )
            }
        }

        return sourceFolders.distinct()
    }

    private fun getSourceFolderFromContentRoot(
        contentRootPath: Path,
        buildUnitDir: Path,
        nestedBuildUnitDirs: Set<Path>,
        contentEntry: ContentEntry,
        sourceFolderService: SourceFolderService,
        sourceFolders: MutableList<SourceFolder>
    ) {
        // Check if this module's content root is within the build unit directory
        // but NOT within any nested build unit directory
        val isWithinBuildUnit = contentRootPath.startsWith(buildUnitDir)
        val isWithinNestedBuildUnit = nestedBuildUnitDirs.any { contentRootPath.startsWith(it) }

        if (isWithinBuildUnit && !isWithinNestedBuildUnit) {
            contentEntry.sourceFolders
                .filter { it.rootType is JavaSourceRootType }
                .filter { !sourceFolderService.isAutogeneratedSourceFolder(it) }
                .forEach { intellijSourceFolder ->
                    val virtualFile = intellijSourceFolder.file
                    if (virtualFile != null) {
                        val sourceFolderPath = Path(virtualFile.path)

                        val codeType = if (intellijSourceFolder.rootType.isForTests) {
                            CodeType.TEST
                        } else {
                            CodeType.PRODUCTION
                        }

                        sourceFolders.add(
                            SourceFolder(
                                path = sourceFolderPath,
                                codeType = codeType
                            )
                        )
                    }
                }
        }
    }
}

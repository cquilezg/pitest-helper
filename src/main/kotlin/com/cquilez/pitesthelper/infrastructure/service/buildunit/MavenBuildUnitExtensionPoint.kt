package com.cquilez.pitesthelper.infrastructure.service.buildunit

import com.cquilez.pitesthelper.domain.BuildSystem
import com.cquilez.pitesthelper.domain.BuildUnit
import com.cquilez.pitesthelper.domain.CodeType
import com.cquilez.pitesthelper.domain.SourceFolder
import com.cquilez.pitesthelper.infrastructure.adapter.buildunit.AbstractBuildUnitExtensionPoint
import com.cquilez.pitesthelper.infrastructure.service.sourcefolder.SourceFolderService
import com.intellij.openapi.components.service
import com.intellij.openapi.module.Module
import com.intellij.openapi.module.ModuleManager
import com.intellij.openapi.project.Project
import com.intellij.openapi.project.rootManager
import com.intellij.openapi.roots.ModuleRootManager
import com.intellij.openapi.vfs.VirtualFile
import kotlinx.collections.immutable.toImmutableSet
import org.jetbrains.jps.model.java.JavaSourceRootType
import java.nio.file.Path
import kotlin.io.path.Path

class MavenBuildUnitExtensionPoint : AbstractBuildUnitExtensionPoint() {

    override fun getBuildSystem(): BuildSystem = BuildSystem.MAVEN

    override fun scanBuildUnits(project: Project): List<BuildUnit> {
        val buildFileInfoList = detectAllBuildFiles(project)
        return buildHierarchyFromBottomToTop(buildFileInfoList)
    }

    private fun detectAllBuildFiles(project: Project): List<BuildFileInfo> {
        val sourceFolderService = project.service<SourceFolderService>()
        val buildFileLocations =
            mutableMapOf<Path, Pair<Path, Module>>()

        val modules = ModuleManager.getInstance(project).modules
        for (module in modules) {
            val pomFiles = findPomFilesInContentRoots(ModuleRootManager.getInstance(module).contentRoots)
            pomFiles.forEach {
                val pomPath = Path(it.path)
                val buildUnitDir = pomPath.parent
                buildFileLocations[buildUnitDir] = Pair(pomPath, module)
            }
        }

        val allBuildUnitDirs = buildFileLocations.keys.toImmutableSet()
        return buildFileLocations.map { (buildUnitDir, buildFileInfo) ->
            val (buildFilePath, module) = buildFileInfo
            val nestedBuildUnitDirs = allBuildUnitDirs.filter { otherDir ->
                otherDir != buildUnitDir && otherDir.startsWith(buildUnitDir)
            }.toSet()

            val sourceFolders =
                findSourceFoldersInModule(module, buildUnitDir, nestedBuildUnitDirs, sourceFolderService)
            BuildFileInfo(BuildSystem.MAVEN, buildFilePath, "pom.xml", sourceFolders)
        }
    }

    private fun findPomFilesInContentRoots(
        contentRoots: Array<out VirtualFile>
    ) : List<VirtualFile>{
        val pomFiles = mutableListOf<VirtualFile>()
        for (contentRoot in contentRoots) {
            val pomFile = contentRoot.findChild("pom.xml")
            if (pomFile != null && pomFile.exists()) {
                pomFiles.add(pomFile)
            }
        }
        return pomFiles
    }

    private fun findSourceFoldersInModule(
        module: Module,
        buildUnitDir: Path,
        nestedBuildUnitDirs: Set<Path>,
        sourceFolderService: SourceFolderService
    ): List<SourceFolder> {
        val sourceFolders = mutableListOf<SourceFolder>()

        module.rootManager.contentEntries.forEach { contentEntry ->
            contentEntry.sourceFolders
                .filter { it.rootType is JavaSourceRootType }
                .filter { !sourceFolderService.isAutogeneratedSourceFolder(it) }
                .forEach { intellijSourceFolder ->
                    val virtualFile = intellijSourceFolder.file
                    if (virtualFile != null) {
                        val sourceFolderPath = Path(virtualFile.path)

                        // Include source folder only if it's within this build unit
                        // but NOT within any nested build unit
                        val isWithinBuildUnit = sourceFolderPath.startsWith(buildUnitDir)
                        val isWithinNestedBuildUnit = nestedBuildUnitDirs.any { sourceFolderPath.startsWith(it) }

                        if (isWithinBuildUnit && !isWithinNestedBuildUnit) {
                            val codeType = if (intellijSourceFolder.rootType.isForTests) {
                                CodeType.TEST
                            } else {
                                CodeType.PRODUCTION
                            }

                            sourceFolders.add(
                                SourceFolder(
                                    path = sourceFolderPath,
                                    codeType = codeType
                                )
                            )
                        }
                    }
                }
        }

        return sourceFolders.distinct()
    }
}

